-- we use a little o for composition
\func \infixl 6 o {A B C : \Type}
	(g : B -> C) (f : A -> B) : A -> C
	=> \lam (x : A) => g(f(x))

-- for those who prefer the diagrammatic order
\func \infixl 6 u {A B C : \Type}
	(f : A -> B) (g : B -> C) : A -> C
	=> g o f

-- definitions for the simple product type
\func \infix 6 xx (A B : \Type) : \Type
	=> \Sigma (x : A) B

-- Redundant clauses are included to show that only by computation do we understand the redundancy
\func recAxxB {A B : \Type}
	(C : \Type) (g : A -> B -> C) (z : A xx B) : C
	| C, g, (a,b) => g(a)(b)
	| C, g, _ => {?}

-- This definition of the inductor is more correct as it reflects the actual computation rule
-- If you view the proof for uniqueness then in context the cononical projections start to make sense
\func indAxxB {A B : \Type}
	(C : A xx B -> \Type) (g : \Pi (x : A) (y : B) -> C(x,y)) (z : A xx B) : C(z)
	| C, g, (a,b) => g(a)(b)
	| C, g, _ => {?}

\func pr1 {A B : \Type}
	(z : A xx B) : A
	=> recAxxB(A)(\lam a b => a)(z)

\func pr2 {A B : \Type}
	(z : A xx B) : B
	=> recAxxB(B)(\lam a b => b)(z)

-- inline for the dependent product type
\func \infix 6 && (A : \Type) (B : A -> \Type) : \Type
	=> \Sigma (x : A) (b : B(x))

\func indA&&B {A : \Type} {B : A -> \Type}
	(C : A && B -> \Type) (g : \Pi(x : A) (y : B(x)) -> C(x,y)) (z : A && B) : C(z)
	| C, g, (a,b) => g(a)(b)
	| C, g, _ => {?}

\func recA&&B {A : \Type} {B : A -> \Type}
	(C : \Type) (g : \Pi(x : A) (y : B(x)) -> C) (z : A && B) : C
	| C, g, (a,b) => g(a)(b)
	| C, g, _ => {?}

-- basic types

\data Zero

-- Exists since functions from zero just trivially do
\func recZero (C : \Type) (z : Zero) : C
-- Exists since functions from zero just trivially do
\func indZero (C : Zero -> \Type) (z : Zero) : C(z)

\data One | star

\func recOne (C : \Type) (c : C) (z : One) : C
  | C, c, One.star => c
  | C, c, _ => {?}

\func indOne (C : One -> \Type) (c : C(One.star)) (x : One) : C(x)
  | C, c, One.star => c
  | _, _, _ => {?}

\data Two | false | true

-- we will use Arend's build int Natural type defined as
{-
\data Nat
  | zero
  | suc Nat
-}

\data Fin (n : Nat) \with
  | suc n => { fzero | fsuc (Fin n) }

-- operations
\func neg (A : \Type) : \Type
	=> A -> Zero

-- standard refl function
\func refl (A : \Type) (a : A) : (a = a)
	=> path(\lam i => a)

-- Standard equality definitions
\func ISO (A : \Type) (B : \Type) : \Type
	=> \Sigma (f : A -> B) (g : B -> A) (pA : (\Pi(a : A) -> g (f a) = a)) (pB : (\Pi(b : B) -> f (g b) = b))

\func sameFunc {A B : \Type}
	(f : A -> B) (g : A -> B) : \Type
	=> \Pi(a : A) -> (f(a) = g(a))
