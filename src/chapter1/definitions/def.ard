-- we use a little o for composition
\func \infixl 6 o {A B C : \Type} (f : A -> B) (g : B -> C) =>
  \lam (x : A) => g (f x)

-- inline for the dependent product type
\func \infix 6 && (A : \Type) (B : A -> \Type) => \Sigma (x : A) (b : B(x))

-- definitions for the simple product type
\func \infix 6 xx (A B : \Type) : \Type => \Sigma (x : A) B

-- Redundant clauses are included to show that only by computation do we understand the redundancy
\func recAxB {A B : \Type} (C : \Type) (g : A -> B -> C) (z : A xx B) : C
  | C, g, (a,b) => g(a)(b)
  | C, g, _ => {?}

-- This definition of the inductor is more correct as it reflects the actual computation rule
-- If you view the proof for uniqueness then in context the cononical projections start to make sense
\func indAxB {A B : \Type} (C : A xx B -> \Type) (g : \Pi (x : A) (y : B) -> C(x,y)) (z : A xx B) : C(z)
  | C, g, (a,b) => g(a)(b)
  | C, g, _ => {?}

\func pr1 {A B : \Type}  (z : A xx B) : A
  => recAxB(A)(\lam a b => a)(z)

\func pr2 {A B : \Type}  (z : A xx B) : B
  => recAxB(B)(\lam a b => b)(z)


-- basic types

\data Zero

\data One | one

\data Two | zero | one

-- we will use Arend's build int Natural type defined as
{-
\data Nat
  | zero
  | suc Nat
-}

\data Fin (n : Nat) \with
  | suc n => { fzero | fsuc (Fin n) }


-- operations
\func neg (A : \Type) : \Type => A -> Zero

-- standard refl type
\func refl (A : \Type) (a : A) : (a = a)
  => path(\lam i => a)

-- Standard isomorphism definition
\func ISO (A : \Type) (B : \Type) : \Type
  => \Sigma (f : A -> B) (g : B -> A) (P1 : (\Pi(a : A) -> g (f a) = a)) (P2 : (\Pi(b : B) -> f (g b) = b))
