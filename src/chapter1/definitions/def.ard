

-- we use a little o for composition
\func \infixl 6 o {A B C : \Type} (f : A -> B) (g : B -> C) =>
  \lam (x : A) => g (f x)


-- inline for the dependent product type
\func \infix 6 && (A : \Type) (B : A -> \Type) => \Sigma (x : A) (b : B(x))
-- definitions for the constant product type
\func \infix 6 xx (A B : \Type) : \Type => \Sigma (x : A) B

\func pr1 {A B : \Type} : A xx B -> A
=> \lam (x : A xx B) => x.1

\func pr2 {A B : \Type} : A xx B -> B
  => \lam (x : A xx B) => x.2

\func recAxB {A B : \Type} : \Pi(C : \Type) -> (A -> B -> C) -> ((A xx B) -> C)
  => \lam C => \lam g => (\lam (x : A xx B) => g(pr1 x)(pr2 x))

\func indAxB {A B : \Type} : \Pi(C : A xx B -> \Type) -> (\Pi (x : A) (y : B) -> C(x,y)) -> \Pi(z : A xx B) -> C(z)
  => \lam C => \lam g => \lam z => g(z.1)(z.2)


-- basic types

\data Zero


\data One | one

\data Two | zero | one

-- we will use Arend's build int Natural type defined as
{-
\data Nat
  | zero
  | suc Nat
-}

\data Fin (n : Nat) \with
  | suc n => { fzero | fsuc (Fin n) }


-- operations

\func neg (A : \Type) : \Type => A -> Zero

-- standard refl type
\func refl (A : \Type) : \Pi (a : A) -> (a = a)
  => \lam a => path(\lam i => a)

-- Standard isomorphism definition
\func ISO (A : \Type) (B : \Type) : \Type
  => \Sigma (f : A -> B) (g : B -> A) (P1 : (\Pi(a : A) -> g (f a) = a)) (P2 : (\Pi(b : B) -> f (g b) = b))



