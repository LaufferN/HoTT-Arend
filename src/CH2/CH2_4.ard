\import CH1.Def.def (xx)
\import CH2.CH2_1
\import CH2.CH2_2
\import CH2.CH2_3

-- 2.4 Homotopies and equivalences

-- tranditionally two functions are equal if they take on the same value, in homotopy theory, this is the definition
-- of homotopy:

\func \infix 4 ~ {A : \Type} {P : A -> \Type} (f g : \Pi (x : A) -> P(x)) : \Type => \Pi (x : A) -> (f x = g x)

-- we will get back to how f ~ g relate to the type f = g (spoiler alert, they are equivalent, via the function e
-- extionality)

-- it is easy to show that ~ is a equivalence relation.

\func ~_is_reflexive {A : \Type} {P : A -> \Type} (f : \Pi (x : A) -> P(x)) : f ~ {A} {P} f => \lam (x : A) => idp

\func ~_is_symmetric {A : \Type} {P : A -> \Type} (f g : \Pi (x : A) -> P(x)) : f ~ {A} {P} g -> g ~{A} {P} f
  => \lam H  x => inv (H x)

\func ~_is_transitive {A : \Type} {P : A -> \Type} (f g h : \Pi (x : A) -> P(x)) : f ~{A} {P} g -> g ~{A}{P} h -> f ~{A}{P} h
  => \lam H H' x => (H x) * (H' x)

-- functions behave categorically like functors, and homotopies behave like natural transformations:

\func ~_is_natural_transformation {A B : \Type} { x y : A} (p : x = y) (f g : A -> B) (H : f ~{A}{\lam x => B} g)
  : (H x) * (ap{A} g p) = (ap f p) * (H y) \elim p | idp => (inv (idp_left_unit{B} {f x} {g x} {H x})) * idp_right_unit

\func inv_is_inverse {A : \Type} {x y z : A} (p : x = y) (q : y = z) : p = (p * q) * inv q \elim p , q
  | idp, idp => idp

-- now we are going to prove a cute lemma:

\func id {A : \Type} : A -> A => \lam x => x

\func Cor2_4_4 {A : \Type} (f : A -> A) (H : f ~ {A}{\lam x => A} id) (x : A) : ap f (H(x)) = H(f x)
  => (((Help1 f H x ) * (Help2 f H x)) * (Help3 f H x)) * (Help4 f H x)

\func Help1 {A : \Type} (f : A -> A) (H : f ~ {A}{\lam x => A} id) (x : A) : ap f (H(x)) = (ap f (H x) * (H x)) * (inv (H x))
  => inv_is_inverse (ap f (H x)) (H x)

\func Help2 {A : \Type} (f : A -> A) (H : f ~ {A}{\lam x => A} id) (x : A) : (ap f (H x) * (H x)) * (inv (H x)) = (H(f x) * (ap id (H x))) * (inv (H x))
  => leftstar (inv (H x)) (inv (~_is_natural_transformation (H x) f id H))

-- need to show that ap of id on any path = path itself.

\func Help3 {A : \Type} (f : A -> A) (H : f ~ {A}{\lam x => A} id) (x : A) : (H(f x) * (ap id (H x))) * (inv (H x)) = (H (f x) * (H (x))) * inv (H x)
  =>  =path_comp (H (f x)) (inv (H x)) (id_func_is_id (H x))

\func =path_comp {A : \Type} {x y z w : A} (p : x = y) {q r : y = z} (t :  z = w) (alpha : q = r) : (p * q) * t = (p * r) * t \elim p, t, alpha
| idp, idp, idp => idp

\func Help4 {A : \Type} (f : A -> A) (H : f ~ {A}{\lam x => A} id) (x : A) :
 (H (f x) * (H (x))) * inv (H x) = H(f x) => inv (inv_is_inverse (H (f x)) (H x))

-- that was no fun at all for sure.

-- moving on to types, we call a function f : A -> B an isomorphism if there is an inverse g that compose both ways to identity.
-- In homotopy theory, we call this a homotopy equivalence. Note that the trivial definition is actually not the one that we want.
-- this is because in fact this choice is not contractible, we call such data quasi-inverse

\func qinv {A B : \Type} (f : A -> B) : \Type => \Sigma (g : B -> A) (alpha : f o g ~ {B} {\lam x => B} id) (beta : g o f ~ {A} {\lam x => A}  id)

-- identity always have a quasi-inverse:

\func id_is_qinv {A : \Type} : qinv (id {A}) => (id {A}, \lam x => idp, \lam x => idp)

-- concatenation of path with p : x = y : y = z -> x = z has inverse, which is concatenating with the inverse path. This is in the exercise
-- tranport has inverse, which is given by transport with the inverse path. This is also homework.

-- now we are goign to define a better version of isequiv. It turns out it is the propositional truncation of qinv(f),
-- but it also have better properties:

-- now let's first define it:

\func isequiv {A B : \Type} (f : A -> B) : \Type => (\Sigma (g : B -> A) (alpha : f o g ~ {B} {\lam x => B} id)) xx
 (\Sigma (h : B -> A) (beta : h o f ~ {A} {\lam x => A}  id))

-- clearly we have quiv f -> isequiv (f):

\func qinv_to_isequiv {A B : \Type} (f : A -> B) : qinv f -> isequiv f => \lam H => ((H.1, H.2) , (H.1, H.3))

-- given (g , alpha, beta), we map it to ((g, alpha), (g, beta)).


-- we will get to more detail about quiv and isequiv later.
-- now an equivalence between A and B, which we have to construct, is f : A -> B together with an inhabitant of
-- isequiv (f).

 \func \infix 9 ISO (A : \Type) (B : \Type) : \Type => \Sigma (f : A -> B) (isequiv f)

-- we will later show that isequiv f is (-1)-truncation, so any two inhabitants are equal.

-- type equivalence is an equivalent relationL

\func ISO_is_reflexive {A : \Type} : A ISO A => (id{A} , qinv_to_isequiv (id{A})  (id_is_qinv {A}))

-- to prove symmetric, we are going to assume that we
\func ISO_is_symmetric {A B : \Type} (H : A ISO B) : B ISO A => {?}