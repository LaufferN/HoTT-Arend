\import CH2.Chpt.sec01

-- 2.2 Functions are functors

{- we are going to see how functions behave with paths. We will see that all functions takes paths
to paths, and higher paths to higher paths. Topologically, we see that all functions are "continuous" -}

-- functions take paths to paths, and it takes reflexivity to reflexivity:

\func ap {A B : \Type} {x y : A} (f : A -> B) (p : x = y) : f x = f y \elim p
  | idp => idp

-- recall that we used ap_succ => ap succ in CH1.Chpt.sec09

-- function ap is called application, or action on paths.

-- basics lemmas about ap f, how it behave with composition and inverses:

\func ap_commute_with_* {A B : \Type} {x y z : A}
                        (p : x = y) (q : y = z) (f : A -> B) :
  ap f (p * q) = (ap f p) * (ap f q) \elim p,q
  | idp , idp => idp

\func ap_commute_with_inv {A B : \Type} {x y z : A}
                          (p : x = y) (f : A -> B) :
  ap f (inv p) = inv (ap f p) \elim p
  | idp => idp

-- recall definition of composition of functions from CH1.Ex.ex01

\import CH1.Def.comp

\func ap_commute_with_comp {A B C : \Type} {x y z : A}
                           (p : x = y) (f : A -> B) (g : B -> C) :
  ap g (ap f p) = ap (g o f) p \elim p
  | idp => idp

-- We recall the identity function

\import CH1.Def.path

-- note that these rule themselves have higher coherence laws.

\func id_func_is_id {A : \Type} {x y : A} (p : x = y) :
  ap id p = p \elim p
  | idp => idp

